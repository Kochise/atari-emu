CLA-VHDL Compiler v1.2 
(Part of the CLA version 2 release 3 package)
 
Preliminary Release Documentation                                  18/7/94 
========================================================================== 
Preface 
------- 
 
VHDL is a derivative of ADA which is aimed at systems modelling and 
ASIC/FPGA/EPLD design. 
 
This documentation is NOT a guide to VHDL. There are many 
good books on this subject. This document just lays out the 
language features which can be handled. 
 
This program (CLAVHDL.PRG) provides a compiler to produce 
CLA blocks from VHDL (VHSIC High-level Design Language) entities. 
 
 However, the subset of VHDL which is supported is quite 
straightforward to understand, so there should be few 
problems..... 
 
NOTE: This is also not really very good documentation for CLA-VHDL either. 
      Tough. The program is quite easy to use though, and I am available 
      via EMAIL or land-mail if you get stuck. Registering will sort you 
      out good & proper though (I'll answer your questions then). 
 
========================================================================== 
ABOUT THE AUTHOR 
---------------- 
I am not rich. I am poor. Register - it may help. 
 
   CRAIG GRAHAM 
   46 School Rd, 
   Langold, 
   Worksop, 
   Notts, 
   S81 9PY. 
   ENGLAND. 
 
EMAIL: craig.graham@newcastle.ac.uk 
 
Copyright 
--------- 
This program is mine. 
I wrote it. 
You may use it, but not modify it. 
It will be still mine though...... 
 
========================================================================== 
Restrictions From Standard VHDL 
------------------------------- 
Before you get your hopes up to much, this is a VERY clipped 
implementation of VHDL. Basically, it only supports data-flow 
modelling via concurent assignment statements of the form 
 
   {signal} <= {boolean}; 
 
Other main restrictions are as follow 
 
- Number of permitted entities per file = one 
- Number of architectures you may have for each entity = one 
- Allowable Data Types - bit. 
- No records, or arrays. 
- Only one clock/sense signal for each PROCESS, and only positive going events 
  are detected. 
 
Ok, I said it was a very limited VHDL compiler. The reasons for 
it existing at all are 
 
   a) To allow me to produce a standard 7400 library quickly 
      without farting about with schematics. 
   b) To let you produce small blocks as boolean equations 
      safe in the knowledge that the block definition will 
      be portable to another platform or design tool. 
   c) Do you know how much a VHDL system will set you back? 
      Model Technology, Mentor Graphics & Intergraph all 
      sell their products (which admitedly are years ahead 
      of this little toy) for VERY large sums - Intergraph's 
      system will set you back in excess of 30,000 pounds 
      (UK) + 20K per year maintenance! Ouch.... 
   d) You use this a a path to simulate state machines design in FSMedit, 
      as that can export designs as VHDL. 
 
NOTE: Although the files generated by this program have a .NET extension, 
      they are not intended to be LOADED by CLA, they are intended to be 
      MERGED. In fact, they will NOT load at all. Attempting to simply 
      load one of these files may result in CLA crashing. 
 
========================================================================== 
Language Definition. 
-------------------- 
 
Having depressed you with what cann't be done, here's what CAN 
be done....and how. 
 
1) Structure 
------------ 
Each VHDL file will start with an ENTITY header. This defines the 
blocks interface to the outside world. You put any port declairations 
you require here. 
 
An entity can be thought of as either a block in a schematic (this is 
the view you should take when dealing with this release of CLA-VHDL, as 
you cann't access other entities from the VHDL at present), or as a 
procedure in a program (if you want to go on to produce whole designs 
in VHDL without any schematics at all-better buy a proper (ie expensive) 
VHDL compiler to do that though). 
 
Format: 
 
   ENTITY {name} IS 
      PORT( {port list} ); 
   END {name}; 
 
Where 
   {port list} = {port name}:{port direction} {port size}; {port list} 
   {port direction} = in | out 
   {port size} = BIT   (for now at least) 
 
Example. 
 
   ENTITY test IS 
      PORT(i1:IN BIT; i2:IN BIT; 
          o1:OUT bit; o2:OUT BIT; 
         ); 
   END test; 
 
The above code fragment declares an ENTITY called test. The resulting block 
will be named after the entity, so in this CASE a block called TEST IS 
produced. It has two inputs (i1 & i2) and two outputs (o1 & o2). 
 
Now the good news.....if you don't have your VHDL written elsewhere, the 
graphical version of CLA-VHDL will write this section for you, from the 
block outline you gave it. So you don't really have to worry about this 
too much. (NOTE: This feature is available on the REGISTERED user's 
version of the compiler, not in this one). 
 
The next section contains the actual definition of what the entity actually 
is. This is where the majority of your coding effort will be. 
 
The format of the ARCHITECTURE section is as follows : 
 
   ARCHITECTURE {arch. name} OF {entity name} IS 
      {signal definitions} 
   BEGIN 
      {code} 
   END; 
 
Look familiar? No? Don't worry. In this implementation, as you can only have 
one architecture for a given entity, the {arch. name} field is fairly 
irrelevant. But you must put it in (call it anything you like) for 
compatibility with other (better) VHDL implementations. 
 
The Signal definitions are like variables inside the entity - they are not 
visible outside like ports are. You can think of them as like wires on a 
circuit board, as you can use them to carry signals around. 
 
 They are declared as follows: 
 
   SIGNAL {signal name}:{port size}; 
 
Easy... 
 
Here is an example of an architecture for our TEST example: 
 
   ARCHITECTURE dataflow OF test IS 
      SIGNAL a:BIT; b:BIT; 
      SIGNAL c:BIT; 
   BEGIN 
   END; 
 
As you can see, there are 3 internal signals (a,b & c). 
Notice that no mention is made of the external ports - they are not 
defined here, they are done in the entity header. 
 
========================================================================== 
2) Assignment statements. 
------------------------- 
 
An entity's behaviour is defined in this version of VHDL as a series of 
CONCURRENT ASSIGNMENT statements. 
 
 This technique is known as DATAFLOW modelling. Better VHDL implementations 
allow more freedom in expressing things than this. 
 
The form of the statement is: 
 
     {signal} <= {boolean equation}; 
              | 
              +-------Assignment operator. 
 
Where a signal is either an internal signal or an output port. 
A boolean equation is and combination of signals and boolean operators. 
 
   VALID BOOLEAN OPERATIONS 
   ------------------------ 
   AND 
   NAND 
   OR 
   NOR 
   XOR 
   NOT 
 
For example, in our earlier example, we could fill in the ARCHITECTURE body 
as follows: 
 
   ARCHITECTURE structure OF test IS 
      SIGNAL a:BIT, b:BIT; 
      SIGNAL c:BIT; 
   BEGIN 
      a<=i1; 
      b<=i2; 
      o1<=NOT a; 
      o2<=b AND i2; 
      o3<=i1 OR i2; 
   END; 
 
More complex equations may be formed using parentheses: 
 
   a<=(a AND not b) OR (b and not a); 
 
actually, though this is a valid equation, the brackets are redundant, 
so you could also write: 
 
   a<=a AND not b OR b AND not a; 
 
As in other languages (such as BASIC), this works due to operator precedance 
(AND is processed before OR, & NOT comes before them all). 
 
NOTE: Although this VHDL compiler supports operator precedance, some don't 
   (eg. the Intergraph simulator), so from a portability point of view, you 
   should write the above line as: 
 
   a<=(a AND not b) OR (b AND not a); 
 
   Or even: 
 
   a<=(a AND (not b)) OR (b AND (not a)); 
 
The CONCURRENT ASSIGNMENT title comes because, unlike Pascal, where if you 
wrote: 
 
   a:=a AND not B OR c; 
   b:=d; 
 
then 'a' would be assigned then 'b' in sequence, VHDL signal assignments occur 
in parallel. 
So 'a' may well get the value required before 'b' is assigned, but equally, it 
may not, as both assignments were made at the same time. This makes the signal 
assignments non-deterministic (wow - thats a good word). Also, the assignments 
continue all the time the simulation is active, so they better model what would 
be happening in an electronic circuit. 
 
CAUTION 
------- 
 
Do NOT make multiple assignments to a signal or an output port. Although as many 
reads from a signal/input can be made as you wish, you must only assign to any 
given signal ONCE. All designers should know this anyway, but for those of you 
just starting on that long road to enlightenment, this causes CONTENTION, where 
one thing may try to force a 1 on a signal at the same time as another is 
trying to force a 0. 
 
========================================================================== 
3) Comments 
------------ 
 
Any lines which begin with -- are comment lines, and as such are ignored 
by the compiler. 
 
eg) 
   -- TEST : An irrelevant and dull VHDL code snippet 
   --        for the masses. 
 
========================================================================== 
4) TEST in full. 
---------------- 
 
Here is the TEST entity example in full: 
 
   -- TEST : An irrelevant and dull VHDL code snippet 
   --        for the masses. 
   -------------------------------------------------- 
   ENTITY test IS 
      PORT(i1:IN BIT; i2:IN BIT; 
          o1:OUT bit; o2:OUT BIT; 
         ); 
   END test; 
 
   ARCHITECTURE structure OF test IS 
      SIGNAL a:BIT; b:BIT; 
      SIGNAL c:BIT; 
   BEGIN 
      a<=i1; 
      b<=i2; 
      o1<=NOT a; 
      o2<=b AND i2; 
      o3<=i1 OR i2; 
   END; 
 
========================================================================== 
5) Event Driven (registered) Logic 
----------------------------------- 
 
VHDL is a concurrent language, and as such, there are ways to force certain 
code fragments to execute only under certain conditions, for example, only 
turn on a light when a person ENTERS a room, not all the time they are there 
('coz the light is already on...). 
 
This is done in VHDL using the PROCESS construct. This allows you to watch 
for changes in a signal (standard VHDL lets you use a list of signals, but 
CLAVHDL only lets you have one). 
 
      PROCESS(<signal>) 
      BEGIN 
         -- put some assignments here 
      END PROCESS; 
 
The assignments between BEGIN & END PROCESS will only be made if there is a 
change in the value of <signal>. 
 
In standard VHDL rise & fall events are detected, but CLAVHDL only detects 
positive going events. 
 
An example modelling a D-flipflip is shown below: 
 
   -- D-FlipFlip Model 
   -------------------------------------------------- 
   ENTITY dflipflop IS 
      PORT(d:IN BIT; clock:IN BIT; 
          q:OUT bit; qbar:OUT BIT; 
         ); 
   END test; 
 
   ARCHITECTURE structure OF dflipflop IS 
   BEGIN 
      PROCESS(clock) 
      BEGIN 
   -- This bit is only executed if clock goes 0->1 
         q<=d; 
         qbar<=NOT q; 
      END PROCESS; 
   END; 
 
========================================================================== 
6) A Proper Example 
------------------- 
 
Below is the full code for a simple IC from CLA's 74xx library. Note that Vcc 
and GND are only included in the port header for completeness in the resulting 
block representation of the chip, and are not actually used. 
 
   -- VHDL Model of an LS7400 
   --  CLA LIBRARY:7400 
   --  Written 4/9/93 by Craig Graham 
   ------------------------------------------- 
   ENTITY LS7400 IS 
      PORT(a1:in bit; b1:in bit; o1:out bit; 
          a2:in bit; b2:in bit; o2:out bit; 
          gnd:in bit; 
          vcc:in bit; 
          a3:in bit; b3:in bit; o3:out bit; 
          a4:in bit; b4:in bit; o4:out bit; 
         ); 
   END LS7400; 
 
   ARCHITECTURE dataflow OF ls7400 is 
   begin 
      o1<=a1 nand b1; 
      o2<=a2 nand b2; 
      o3<=a3 nand b3; 
      o4<=a4 nand b4; 
   end; 
 
There, easy isn't it.....

